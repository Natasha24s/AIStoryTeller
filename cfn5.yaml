AWSTemplateFormatVersion: '2010-09-09'
Description: 'Template for API Gateway triggering Step Function with two Lambda steps'

Parameters:
  SourceBucketName:
    Type: String
    Description: Name of the source S3 bucket for images
  DestinationBucketName:
    Type: String
    Description: Name of the destination S3 bucket for videos

Resources:
  # S3 Buckets
  SourceBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref SourceBucketName

  DestinationBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref DestinationBucketName

  # IAM Roles
  FirstLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3AndBedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource: 
                  - !Sub ${SourceBucket.Arn}/*
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:Converse
                Resource: '*'

  SecondLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3AndBedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: 
                  - !Sub ${SourceBucket.Arn}/*
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: 
                  - !Sub ${DestinationBucket.Arn}/*
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:StartAsyncInvoke
                  - bedrock:GetAsyncInvoke
                Resource: '*'

  # First Lambda Function with your new code
  FirstLambda:
    Type: AWS::Lambda::Function
    DependsOn:
      - FirstLambdaRole
      - SourceBucket
    Properties:
      FunctionName: StoryGeneratorFunction
      Handler: index.handler
      Role: !GetAtt FirstLambdaRole.Arn
      Code:
        ZipFile: |
          # Your new Lambda code here
  # Second Lambda Function
  SecondLambda:
    Type: AWS::Lambda::Function
    DependsOn:
      - SecondLambdaRole
      - SourceBucket
      - DestinationBucket
    Properties:
      FunctionName: VideoGeneratorFunction
      Handler: index.handler
      Role: !GetAtt SecondLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import logging
          import time
          import random
          from typing import Dict, Any, Tuple

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          SOURCE_BUCKET = os.environ.get('SOURCE_BUCKET', 'story-story-images')
          DESTINATION_BUCKET = os.environ.get('DESTINATION_BUCKET', 'story-video-output')
          MODEL_ID = "amazon.nova-reel-v1:1"
          SLEEP_SECONDS = 15
          MAX_MONITORING_TIME = 900

          def load_scenes_from_s3(bucket: str, story_id: str) -> dict:
              try:
                  s3_client = boto3.client('s3')
                  file_path = f"{story_id}/scenes.json"
                  logger.info(f"Attempting to load scenes.json from {bucket}/{file_path}")
                  
                  response = s3_client.get_object(
                      Bucket=bucket,
                      Key=file_path
                  )
                  scenes = json.loads(response['Body'].read().decode('utf-8'))
                  logger.info(f"Successfully loaded scenes: {json.dumps(scenes, indent=2)}")
                  return scenes
              except Exception as e:
                  logger.error(f"Error loading scenes.json from {file_path}: {str(e)}")
                  raise

          def check_image_exists(bucket: str, story_id: str, scene_num: int) -> bool:
              try:
                  s3_client = boto3.client('s3')
                  image_path = f"{story_id}/scene_{scene_num}.png"
                  s3_client.head_object(Bucket=bucket, Key=image_path)
                  logger.info(f"Image found: {image_path}")
                  return True
              except Exception as e:
                  logger.info(f"Image not found: {image_path}")
                  return False

          def get_model_input(story_id: str) -> dict:
              try:
                  if not story_id:
                      raise ValueError("story_id is required in the event")
                  
                  logger.info(f"Processing story_id: {story_id}")
                  scenes = load_scenes_from_s3(SOURCE_BUCKET, story_id)
                  shots = []
                  shot_keys = sorted([k for k in scenes.keys() if k.startswith('shot') and k.endswith('_text')])
                  
                  logger.info(f"Found {len(shot_keys)} shots to process")
                  
                  for shot_key in shot_keys:
                      if scenes[shot_key]:
                          shot_num = int(shot_key.replace('shot', '').replace('_text', ''))
                          shot = {
                              "text": scenes[shot_key].strip()
                          }
                          
                          if check_image_exists(SOURCE_BUCKET, story_id, shot_num):
                              shot["image"] = {
                                  "format": "png",
                                  "source": {
                                      "s3Location": {
                                          "uri": f"s3://{SOURCE_BUCKET}/{story_id}/scene_{shot_num}.png"
                                      }
                                  }
                              }
                          
                          shots.append(shot)
                          logger.info(f"Processed {shot_key} successfully")
                  
                  if not shots:
                      raise ValueError("No valid shots found in scenes.json")
                  
                  model_input = {
                      "taskType": "MULTI_SHOT_MANUAL",
                      "multiShotManualParams": {
                          "shots": shots
                      },
                      "videoGenerationConfig": {
                          "seed": random.randint(0, 2147483648),
                          "fps": 24,
                          "dimension": "1280x720"
                      }
                  }
                  
                  logger.info(f"Created model input: {json.dumps(model_input, indent=2)}")
                  return model_input
                  
              except Exception as e:
                  logger.error(f"Error in get_model_input: {str(e)}")
                  raise

          def monitor_video_generation(bedrock_client, invocation_arn: str) -> Tuple[str, str]:
              job_id = invocation_arn.split("/")[-1]
              s3_location = f"s3://{DESTINATION_BUCKET}/{job_id}"
              start_time = time.time()
              
              logger.info(f"Monitoring job folder: {s3_location}")
              
              while True:
                  try:
                      response = bedrock_client.get_async_invoke(invocationArn=invocation_arn)
                      status = response["status"]
                      logger.info(f"Status: {status}")
                      
                      if status != "InProgress":
                          break
                          
                      if time.time() - start_time > MAX_MONITORING_TIME:
                          logger.warning("Maximum monitoring time exceeded")
                          return "Timeout", s3_location
                          
                      time.sleep(SLEEP_SECONDS)
                      
                  except Exception as e:
                      logger.error(f"Error monitoring video generation: {str(e)}")
                      return "Error", s3_location
              
              output_location = f"{s3_location}/output.mp4" if status == "Completed" else None
              return status, output_location

          def handler(event: dict, context: Any) -> Dict[str, Any]:
              try:
                  logger.info(f"Received event: {json.dumps(event)}")
                  story_id = event.get('story_id')
                  
                  if not story_id:
                      raise ValueError("story_id is required in the event")

                  bedrock_client = boto3.client('bedrock-runtime')
                  
                  model_input = get_model_input(story_id)
                  
                  invocation = bedrock_client.start_async_invoke(
                      modelId=MODEL_ID,
                      modelInput=model_input,
                      outputDataConfig={
                          "s3OutputDataConfig": {
                              "s3Uri": f"s3://{DESTINATION_BUCKET}"
                          }
                      }
                  )
                  
                  invocation_arn = invocation["invocationArn"]
                  status, output_location = monitor_video_generation(bedrock_client, invocation_arn)
                  
                  response = {
                      'statusCode': 200,
                      'body': {
                          'status': status,
                          'story_id': story_id,
                          'source_bucket': SOURCE_BUCKET,
                          'destination_bucket': DESTINATION_BUCKET,
                          'output_location': output_location,
                          'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
                      }
                  }
                  
                  if status == "Completed":
                      response['body']['message'] = 'Video generation completed successfully'
                  elif status == "Failed":
                      response['statusCode'] = 500
                      response['body']['message'] = 'Video generation failed'
                  elif status == "Timeout":
                      response['statusCode'] = 408
                      response['body']['message'] = 'Video generation monitoring timed out'
                  else:
                      response['body']['message'] = f'Video generation status: {status}'
                  
                  logger.info(f"Final response: {json.dumps(response, default=str)}")
                  return response

              except Exception as err:
                  logger.error(f"Error in lambda_handler: {str(err)}", exc_info=True)
                  return {
                      'statusCode': 500,
                      'body': {
                          'error': str(err),
                          'status': 'Error',
                          'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
                      }
                  }

      Runtime: python3.9
      Timeout: 900
      MemorySize: 1024
      Environment:
        Variables:
          SOURCE_BUCKET: !Ref SourceBucketName
          DESTINATION_BUCKET: !Ref DestinationBucketName

  # Step Functions with updated definition
  StatesExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaInvoke
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt FirstLambda.Arn
                  - !GetAtt SecondLambda.Arn

  StoryProcessingStateMachine:
    Type: AWS::StepFunctions::StateMachine
    DependsOn:
      - FirstLambda
      - SecondLambda
      - StatesExecutionRole
    Properties:
      RoleArn: !GetAtt StatesExecutionRole.Arn
      DefinitionString: !Sub |
        {
          "Comment": "Story Generation and Video Creation workflow",
          "StartAt": "GenerateStory",
          "States": {
            "GenerateStory": {
              "Type": "Task",
              "Resource": "${FirstLambda.Arn}",
              "Next": "ParseResponse",
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "HandleError"
                }
              ]
            },
            "ParseResponse": {
              "Type": "Pass",
              "Parameters": {
                "story_id.$": "States.StringToJson($.body).story_id"
              },
              "Next": "GenerateVideo"
            },
            "GenerateVideo": {
              "Type": "Task",
              "Resource": "${SecondLambda.Arn}",
              "OutputPath": "$.body",
              "End": true,
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "HandleError"
                }
              ]
            },
            "HandleError": {
              "Type": "Pass",
              "End": true,
              "ResultPath": "$.error"
            }
          }
        }
  # API Gateway Role with updated permissions
  ApiGatewayRole:
    Type: AWS::IAM::Role
    DependsOn: StoryProcessingStateMachine
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: StepFunctionsExecution
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                  - states:DescribeExecution
                Resource: 
                  - !Ref StoryProcessingStateMachine
                  - !Sub arn:aws:states:${AWS::Region}:${AWS::AccountId}:execution:${StoryProcessingStateMachine.Name}:*

  # API Gateway Resources
  Api:
    Type: AWS::ApiGateway::RestApi
    DependsOn: ApiGatewayRole
    Properties:
      Name: StoryGeneratorAPI

  ApiResource:
    Type: AWS::ApiGateway::Resource
    DependsOn: Api
    Properties:
      RestApiId: !Ref Api
      ParentId: !GetAtt Api.RootResourceId
      PathPart: generate

  StatusResource:
    Type: AWS::ApiGateway::Resource
    DependsOn: Api
    Properties:
      RestApiId: !Ref Api
      ParentId: !GetAtt Api.RootResourceId
      PathPart: status

  ApiMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: 
      - ApiGatewayRole
      - ApiResource
      - StoryProcessingStateMachine
    Properties:
      RestApiId: !Ref Api
      ResourceId: !Ref ApiResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:states:action/StartExecution
        Credentials: !GetAtt ApiGatewayRole.Arn
        RequestTemplates:
          application/json: !Sub |
            {
              "stateMachineArn": "${StoryProcessingStateMachine}",
              "input": "{\"topic\": \"$input.path('$.topic')\"}"
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: |
                {
                  "executionArn": $input.json('$.executionArn'),
                  "startDate": $input.json('$.startDate'),
                  "message": "Story generation process started successfully",
                  "status": "IN_PROGRESS"
                }
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: "Empty"

  StatusMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: 
      - ApiGatewayRole
      - StatusResource
      - StoryProcessingStateMachine
    Properties:
      RestApiId: !Ref Api
      ResourceId: !Ref StatusResource
      HttpMethod: GET
      AuthorizationType: NONE
      RequestParameters:
        method.request.querystring.executionArn: true
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:states:action/DescribeExecution
        Credentials: !GetAtt ApiGatewayRole.Arn
        RequestTemplates:
          application/json: |
            {
              "executionArn": "$input.params('executionArn')"
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: |
                #set($inputRoot = $input.path('$'))
                #if($inputRoot.status == "SUCCEEDED" && $inputRoot.output)
                    $inputRoot.output
                #else
                    {
                        "executionArn": "$inputRoot.executionArn",
                        "status": "$inputRoot.status",
                        "startDate": "$inputRoot.startDate",
                        #if($inputRoot.stopDate)"stopDate": "$inputRoot.stopDate",#end
                        "message": "Execution in progress"
                    }
                #end
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: "Empty"

  # Create deployment after all methods are created
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: 
      - ApiMethod
      - StatusMethod
      - ApiResource
      - StatusResource
    Properties:
      RestApiId: !Ref Api
      Description: "Production deployment"

  # Create stage after deployment
  ApiStage:
    Type: AWS::ApiGateway::Stage
    DependsOn: ApiDeployment
    Properties:
      DeploymentId: !Ref ApiDeployment
      RestApiId: !Ref Api
      StageName: prod

Outputs:
  ApiEndpoint:
    Description: API Endpoint URL for generating story
    Value: !Sub https://${Api}.execute-api.${AWS::Region}.amazonaws.com/prod/generate
  StatusEndpoint:
    Description: API Endpoint URL for checking status
    Value: !Sub https://${Api}.execute-api.${AWS::Region}.amazonaws.com/prod/status
  StateMachineArn:
    Description: State Machine ARN
    Value: !Ref StoryProcessingStateMachine
